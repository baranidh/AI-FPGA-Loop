<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI-FPGA-Loop | Interactive Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg:     #0d1117;
      --bg2:    #161b22;
      --bg3:    #21262d;
      --border: #30363d;
      --text:   #c9d1d9;
      --dim:    #8b949e;
      --green:  #3fb950;
      --cyan:   #79c0ff;
      --yellow: #d29922;
      --red:    #f85149;
      --blue:   #58a6ff;
      --purple: #bc8cff;
      --orange: #f0883e;
    }
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Consolas', 'Cascadia Code', 'Menlo', monospace;
      font-size: 12.5px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ── Header ── */
    header {
      background: var(--bg2);
      border-bottom: 1px solid var(--border);
      padding: 7px 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }
    header h1 { font-size: 14px; font-weight: bold; color: var(--cyan); letter-spacing: .04em; }
    .badge {
      background: var(--bg3); border: 1px solid var(--border);
      border-radius: 4px; padding: 1px 7px; font-size: 10.5px; color: var(--dim);
    }
    #status-badge { border-color: var(--cyan); color: var(--cyan); }

    /* ── Layout ── */
    .main {
      display: grid;
      grid-template-columns: 234px 1fr;
      flex: 1;
      overflow: hidden;
    }

    /* ── Sidebar ── */
    .sidebar {
      background: var(--bg2);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .sec-title {
      color: var(--dim); font-size: 10px; text-transform: uppercase;
      letter-spacing: .1em; border-bottom: 1px solid var(--border);
      padding-bottom: 3px; margin-bottom: 5px;
    }
    label { color: var(--dim); font-size: 10.5px; display: block; margin-bottom: 2px; }
    .row { display: flex; align-items: center; gap: 6px; }
    input[type="range"] { flex: 1; accent-color: var(--cyan); cursor: pointer; }
    .val { color: var(--cyan); font-size: 11.5px; min-width: 32px; text-align: right; }
    input[type="number"], select {
      background: var(--bg3); border: 1px solid var(--border);
      color: var(--text); padding: 3px 7px; border-radius: 4px;
      font-family: inherit; font-size: 11.5px; width: 100%;
    }
    .btn-row { display: flex; gap: 5px; }
    button {
      flex: 1; background: var(--bg3); border: 1px solid var(--border);
      color: var(--text); padding: 5px 8px; cursor: pointer;
      border-radius: 4px; font-family: inherit; font-size: 11.5px; transition: background .12s;
    }
    button:hover { background: #2d333b; }
    button.go   { background: #162016; border-color: var(--green); color: var(--green); }
    button.go:hover { background: #1f3a1f; }
    button.stop { background: #211515; border-color: var(--red); color: var(--red); }
    button.stop:hover { background: #3a1a1a; }
    button.warn { background: #1e1a10; border-color: var(--yellow); color: var(--yellow); }
    button.warn:hover { background: #302813; }
    button:disabled { opacity: .4; cursor: not-allowed; }

    .cfg-table { width: 100%; border-collapse: collapse; font-size: 11.5px; }
    .cfg-table td { padding: 2px 3px; }
    .cfg-table td:first-child { color: var(--dim); }
    .cfg-table td:last-child  { color: var(--cyan); font-weight: bold; }

    .mcard {
      background: var(--bg3); border: 1px solid var(--border);
      border-radius: 4px; padding: 5px 7px;
    }
    .mcard .ml { font-size: 10px; color: var(--dim); }
    .mcard .mv { font-size: 13px; font-weight: bold; color: var(--cyan); }
    .mv.g { color: var(--green); } .mv.y { color: var(--yellow); } .mv.r { color: var(--red); }

    .mg { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }

    /* ── Content ── */
    .content {
      display: grid;
      grid-template-rows: 210px 1fr 165px;
      overflow: hidden;
    }

    /* ── Top row ── */
    .top-row {
      display: grid;
      grid-template-columns: 2fr 1fr;
      border-bottom: 1px solid var(--border);
      overflow: hidden;
    }
    .chart-wrap {
      padding: 8px 10px;
      border-right: 1px solid var(--border);
      display: flex; flex-direction: column; overflow: hidden;
    }
    .chart-wrap canvas { flex: 1; min-height: 0; }

    .info-panel {
      padding: 8px 10px;
      display: flex; flex-direction: column; gap: 7px; overflow-y: auto;
    }
    .prog-bar { background: var(--bg3); border-radius: 99px; height: 6px; overflow: hidden; }
    .prog-fill {
      height: 100%; background: linear-gradient(90deg, var(--blue), var(--cyan));
      transition: width .3s; border-radius: 99px;
    }
    .best-box {
      background: var(--bg3); border: 1px solid var(--green);
      border-radius: 4px; padding: 7px 9px;
    }
    .best-r { font-size: 22px; font-weight: bold; color: var(--green); line-height: 1.1; }
    .best-sub { font-size: 10.5px; color: var(--dim); margin-top: 3px; }
    .best-met { font-size: 11px; color: var(--cyan); margin-top: 2px; }

    /* ── Log ── */
    .log-panel { display: flex; flex-direction: column; overflow: hidden; }
    .log-hdr {
      background: var(--bg2); border-bottom: 1px solid var(--border);
      padding: 4px 10px; font-size: 10.5px; color: var(--dim);
      display: flex; align-items: center; gap: 8px; flex-shrink: 0;
    }
    .log-hdr button { flex: none; padding: 1px 8px; font-size: 10px; }
    .log-scroll { overflow-y: auto; flex: 1; }
    .log-tbl { width: 100%; border-collapse: collapse; font-size: 11px; }
    .log-tbl th {
      background: var(--bg2); color: var(--dim); padding: 3px 7px;
      text-align: left; position: sticky; top: 0; border-bottom: 1px solid var(--border);
      font-size: 10.5px; font-weight: normal; white-space: nowrap;
    }
    .log-tbl td { padding: 2.5px 7px; border-bottom: 1px solid rgba(48,54,61,.4); white-space: nowrap; }
    .log-tbl tr:hover td { background: var(--bg3); }
    .log-tbl tr.best-row td { background: rgba(63,185,80,.07); }
    .me { color: var(--blue); } .mx { color: var(--green); }
    .rg { color: var(--green); } .ry { color: var(--yellow); } .rr { color: var(--red); }

    /* ── Verilog ── */
    .verilog-panel {
      border-top: 1px solid var(--border);
      display: flex; flex-direction: column; overflow: hidden;
    }
    .verilog-hdr {
      background: var(--bg2); border-bottom: 1px solid var(--border);
      padding: 4px 10px; font-size: 10.5px; color: var(--dim);
      display: flex; align-items: center; justify-content: space-between; flex-shrink: 0;
    }
    .verilog-hdr span { color: var(--cyan); margin-left: 5px; }
    .vbtn-grp { display: flex; gap: 4px; }
    .vbtn-grp button { flex: none; padding: 1px 8px; font-size: 10px; }
    .vcode {
      flex: 1; overflow: auto; padding: 6px 10px;
      font-size: 11px; line-height: 1.55; background: #090d12; color: var(--text);
    }

    /* Verilog syntax */
    .vkw  { color: #ff7b72; }
    .vmod { color: #ffa657; font-weight: bold; }
    .vpar { color: var(--purple); }
    .vnum { color: #a5d6ff; }
    .vcmt { color: #6a737d; font-style: italic; }
    .vdir { color: var(--cyan); }

    /* ── Pulse animation ── */
    @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:.3; } }
    .dot { display: inline-block; width: 7px; height: 7px; border-radius: 50%;
           background: var(--green); animation: pulse 1s infinite; margin-right: 4px; }

    /* scrollbar */
    ::-webkit-scrollbar { width: 5px; height: 5px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  </style>
</head>
<body>

<!-- ── Header ─────────────────────────────────────────────────────── -->
<header>
  <h1>⚡ AI-FPGA-Loop</h1>
  <span class="badge">Interactive Simulator</span>
  <span class="badge" id="status-badge">Ready</span>
  <span style="margin-left:auto;font-size:10.5px;color:var(--dim)">
    648 configs · Tabular Q-learning · TinyMLP 8→16→4 · NN inference reward
  </span>
</header>

<!-- ── Main ───────────────────────────────────────────────────────── -->
<div class="main">

  <!-- Sidebar -->
  <div class="sidebar">

    <!-- Controls -->
    <div>
      <div class="sec-title">Controls</div>
      <div style="display:flex;flex-direction:column;gap:6px">
        <div>
          <label>Learning rate (α)</label>
          <div class="row">
            <input type="range" id="lr-r" min=".01" max=".5" step=".01" value=".1">
            <span class="val" id="lr-v">0.10</span>
          </div>
        </div>
        <div>
          <label>Initial ε (epsilon)</label>
          <div class="row">
            <input type="range" id="eps-r" min=".05" max="1" step=".05" value=".9">
            <span class="val" id="eps-v">0.90</span>
          </div>
        </div>
        <div>
          <label>ε decay / iteration</label>
          <div class="row">
            <input type="range" id="decay-r" min=".9" max=".999" step=".001" value=".97">
            <span class="val" id="decay-v">0.970</span>
          </div>
        </div>
        <div>
          <label>Iterations to run</label>
          <input type="number" id="iters-n" value="50" min="1" max="648">
        </div>
        <div>
          <label>Speed</label>
          <select id="speed-s">
            <option value="0">⚡ Instant (batch)</option>
            <option value="80">Fast (80 ms)</option>
            <option value="250" selected>Normal (250 ms)</option>
            <option value="600">Slow (600 ms)</option>
            <option value="1200">Very slow (1.2 s)</option>
          </select>
        </div>
      </div>
    </div>

    <div class="btn-row">
      <button id="run-btn" class="go" onclick="toggleRun()">▶ Run</button>
      <button id="step-btn"           onclick="stepOne()">⏭ Step</button>
    </div>
    <div class="btn-row">
      <button class="warn" onclick="resetAgent()">↺ Reset</button>
      <button onclick="resetAgent(true)">↺ + reset ε</button>
    </div>

    <!-- Current config -->
    <div>
      <div class="sec-title">Current Config</div>
      <table class="cfg-table" id="cfg-tbl">
        <tr><td>bit_w</td>       <td id="c0">—</td></tr>
        <tr><td>vec_len</td>     <td id="c1">—</td></tr>
        <tr><td>pipe_stages</td> <td id="c2">—</td></tr>
        <tr><td>act_type</td>    <td id="c3">—</td></tr>
        <tr><td>accum_extra</td> <td id="c4">—</td></tr>
        <tr><td>use_dsp</td>     <td id="c5">—</td></tr>
      </table>
    </div>

    <!-- Last metrics -->
    <div>
      <div class="sec-title">Last Metrics</div>
      <div class="mg">
        <div class="mcard"><div class="ml">LUTs</div>   <div class="mv" id="m0">—</div></div>
        <div class="mcard"><div class="ml">Freq</div>   <div class="mv" id="m1">—</div></div>
        <div class="mcard"><div class="ml">Tput MOPS</div><div class="mv" id="m2">—</div></div>
        <div class="mcard"><div class="ml">FPGA Acc</div><div class="mv" id="m3">—</div></div>
        <div class="mcard" style="grid-column:1/-1">
          <div class="ml">FP32 Acc <span id="fp32-acc" style="color:var(--cyan);margin-left:4px">—</span>
          &nbsp;·&nbsp; Ratio <span id="acc-ratio" style="color:var(--purple)">—</span></div>
        </div>
        <div class="mcard" style="grid-column:1/-1">
          <div class="ml">Reward</div>
          <div class="mv" id="m4" style="font-size:18px">—</div>
        </div>
      </div>
    </div>

    <!-- Top 3 -->
    <div>
      <div class="sec-title">Top-3 by Q-value</div>
      <div id="top3" style="font-size:11px;color:var(--dim)">Run to explore configs.</div>
    </div>

    <!-- AI insights -->
    <div>
      <div class="sec-title">AI Insights</div>
      <div id="insights" style="font-size:11px;color:var(--dim)">Needs ≥ 8 iterations.</div>
    </div>

  </div><!-- /sidebar -->

  <!-- Content -->
  <div class="content">

    <!-- Top row: chart + stats -->
    <div class="top-row">
      <div class="chart-wrap">
        <div class="sec-title" style="margin-bottom:4px">Reward over Iterations</div>
        <canvas id="chart"></canvas>
      </div>

      <div class="info-panel">
        <div class="sec-title">Exploration</div>
        <div style="font-size:11.5px">
          <span id="exp-n" style="color:var(--cyan)">0</span>
          <span style="color:var(--dim)"> / 648 configs explored</span>
        </div>
        <div class="prog-bar"><div class="prog-fill" id="exp-bar" style="width:0%"></div></div>
        <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--dim)">
          <span>ε = <span id="eps-live" style="color:var(--cyan)">0.900</span></span>
          <span>iter <span id="iter-n" style="color:var(--cyan)">0</span></span>
        </div>

        <div class="sec-title">Best Design Found</div>
        <div class="best-box">
          <div class="best-r" id="best-r">—</div>
          <div class="best-sub" id="best-cfg">Run to find the best design</div>
          <div class="best-met" id="best-met"></div>
        </div>
        <div style="font-size:11px;color:var(--dim)">
          Trend: <span id="trend" style="color:var(--cyan)">—</span>
        </div>
      </div>
    </div><!-- /top-row -->

    <!-- Iteration log -->
    <div class="log-panel">
      <div class="log-hdr">
        <span><span class="dot" id="run-dot" style="display:none"></span>
          Iteration Log — <span id="log-n" style="color:var(--cyan)">0</span> iterations</span>
        <span style="margin-left:auto"></span>
        <button onclick="clearLog()">Clear</button>
      </div>
      <div class="log-scroll" id="log-scroll">
        <table class="log-tbl">
          <thead><tr>
            <th>#</th><th>Method</th><th>bit_w</th><th>vec</th>
            <th>pipe</th><th>act</th><th>dsp</th>
            <th>LUTs</th><th>Freq</th><th>Tput MOPS</th>
            <th>FP32%</th><th>FPGA%</th><th>Ratio</th><th>Reward</th>
          </tr></thead>
          <tbody id="log-body"></tbody>
        </table>
      </div>
    </div>

    <!-- Verilog viewer -->
    <div class="verilog-panel">
      <div class="verilog-hdr">
        <div>Verilog — <span id="v-label">no design yet</span></div>
        <div class="vbtn-grp">
          <button id="copy-btn" onclick="copyV()">Copy</button>
          <button onclick="downloadV()">Download</button>
        </div>
      </div>
      <div class="vcode" id="vcode">
        <span class="vcmt">// Generated Verilog appears here after each iteration (new best or every 5 steps)</span>
      </div>
    </div>

  </div><!-- /content -->
</div><!-- /main -->

<script>
// ═══════════════════════════════════════════════════════════════════════════
// DESIGN SPACE
// ═══════════════════════════════════════════════════════════════════════════

const PARAM_SPACE = {
  bit_w:       [4, 8, 16],
  vec_len:     [2, 4, 8, 16],
  pipe_stages: [1, 2, 3],
  act_type:    [0, 1, 2],
  accum_extra: [2, 4, 8],
  use_dsp:     [0, 1],
};
const PNAMES = Object.keys(PARAM_SPACE);
const ACT    = {0:'wrap', 1:'relu', 2:'clamp'};

function allConfigs() {
  const vals = PNAMES.map(k => PARAM_SPACE[k]);
  const out = [];
  function rec(i, cur) {
    if (i === PNAMES.length) { out.push({...cur}); return; }
    for (const v of vals[i]) { cur[PNAMES[i]] = v; rec(i+1, cur); }
  }
  rec(0, {});
  return out;
}

const ALL = allConfigs();   // 648 configs
const NTOT = ALL.length;    // 648

function cfgKey(c) { return PNAMES.map(k => c[k]).join(','); }

// ═══════════════════════════════════════════════════════════════════════════
// SEEDED PRNG (Mulberry32) + Box-Muller Gaussian
// ═══════════════════════════════════════════════════════════════════════════

function seededRng(seed) {
  let s = seed >>> 0;
  return function() {
    s = (s + 0x6D2B79F5) >>> 0;
    let t = Math.imul(s ^ (s >>> 15), s | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function gaussRng(rng) {
  let u; do { u = rng(); } while (u === 0);
  return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * rng());
}

// ═══════════════════════════════════════════════════════════════════════════
// SYNTHETIC DATASET  (4 classes · 8 features · Gaussian clusters)
// mirrors dataset.py — separable enough for 8-bit, tough for 4-bit
// ═══════════════════════════════════════════════════════════════════════════

function makeDataset(nPerClass, seed) {
  const rng = seededRng(seed), g = () => gaussRng(rng);
  const NC = 4, NF = 8;
  const ctrs = Array.from({length:NC}, () => Array.from({length:NF}, () => g() * 3.0));
  const X = [], y = [];
  for (let c = 0; c < NC; c++) {
    for (let i = 0; i < nPerClass; i++) { X.push(ctrs[c].map(mu => mu + g() * 0.9)); y.push(c); }
  }
  const rng2 = seededRng(seed + 7);
  const idx  = Array.from({length:X.length}, (_,i)=>i).sort(() => rng2() - 0.5);
  const Xs = idx.map(i=>X[i]), ys = idx.map(i=>y[i]);
  const n = Xs.length;
  const mu = Array(NF).fill(0), sg = Array(NF).fill(0);
  Xs.forEach(x => x.forEach((v,f) => mu[f] += v/n));
  Xs.forEach(x => x.forEach((v,f) => sg[f] += (v-mu[f])**2/n));
  sg.forEach((_,f) => sg[f] = Math.sqrt(sg[f]) || 1);
  return {X: Xs.map(x => x.map((v,f) => (v-mu[f])/sg[f])), y: ys};
}

// ═══════════════════════════════════════════════════════════════════════════
// QUANTIZE HELPERS
// ═══════════════════════════════════════════════════════════════════════════

function quantize2d(W, bw) {
  const cMax = (1<<(bw-1))-1, cMin = -(1<<(bw-1));
  let abs = 0; for (const r of W) for (const v of r) if (Math.abs(v)>abs) abs=Math.abs(v);
  const sc = abs > 0 ? abs/cMax : 1;
  return W.map(r => r.map(v => Math.max(cMin, Math.min(cMax, Math.round(v/sc)))));
}
function quantize1d(b, bw) {
  const cMax = (1<<(bw-1))-1, cMin = -(1<<(bw-1));
  let abs = 0; for (const v of b) if (Math.abs(v)>abs) abs=Math.abs(v);
  const sc = abs > 0 ? abs/cMax : 1;
  return b.map(v => Math.max(cMin, Math.min(cMax, Math.round(v/sc))));
}

// ═══════════════════════════════════════════════════════════════════════════
// FPGA LAYER  (mirrors neural_net.py → fpga_layer)
// ═══════════════════════════════════════════════════════════════════════════

function fpgaLayer(Xq, Wq, bq, cfg, applyAct) {
  const {bit_w, vec_len, act_type} = cfg;
  const cMax = (1<<(bit_w-1))-1, cMin = -(1<<(bit_w-1));
  const inDim = Wq.length, outDim = Wq[0].length;
  return Xq.map(xRow => Array.from({length:outDim}, (_,j) => {
    let acc = bq[j];
    for (let st=0; st<inDim; st+=vec_len) {
      const en = Math.min(st+vec_len, inDim);
      for (let k=st; k<en; k++) acc += xRow[k] * Wq[k][j];
    }
    if (!applyAct) return acc;
    if (act_type===1) return acc<0 ? 0 : acc>cMax ? cMax : acc;      // ReLU
    if (act_type===2) return acc<cMin ? cMin : acc>cMax ? cMax : acc; // clamp
    let r = ((acc%(1<<bit_w))+(1<<bit_w))%(1<<bit_w);                 // wrap
    if (r>=(1<<(bit_w-1))) r -= (1<<bit_w);
    return r;
  }));
}

// ═══════════════════════════════════════════════════════════════════════════
// TINY MLP  8 → 16 (ReLU) → 4  (mirrors neural_net.py TinyMLP)
// ═══════════════════════════════════════════════════════════════════════════

class TinyMLP {
  constructor(seed) {
    const rng = seededRng(seed+1000), g = () => gaussRng(rng);
    this.W1 = Array.from({length:8},  () => Array.from({length:16}, () => g()*Math.sqrt(2/8)));
    this.b1 = Array(16).fill(0);
    this.W2 = Array.from({length:16}, () => Array.from({length:4},  () => g()*Math.sqrt(2/16)));
    this.b2 = Array(4).fill(0);
  }

  _fwd(X) {
    const H = X.map(x => Array.from({length:16}, (_,j) => {
      let a=this.b1[j]; for(let i=0;i<8;i++) a+=x[i]*this.W1[i][j]; return a<0?0:a;
    }));
    return {H, logits: H.map(h => Array.from({length:4}, (_,j) => {
      let a=this.b2[j]; for(let i=0;i<16;i++) a+=h[i]*this.W2[i][j]; return a;
    }))};
  }

  fp32Accuracy(X, y) {
    return this._fwd(X).logits.reduce((s,l,i) =>
      s + (l.indexOf(Math.max(...l))===y[i] ? 1 : 0), 0) / X.length;
  }

  // Mini-batch SGD with cross-entropy loss
  train(X, y, epochs, lr, bs) {
    const n=X.length, rng=seededRng(99);
    for (let ep=0; ep<epochs; ep++) {
      const idx = Array.from({length:n}, (_,i)=>i).sort(() => rng()-0.5);
      for (let s=0; s<n; s+=bs) {
        const b=idx.slice(s,s+bs), Xb=b.map(i=>X[i]), yb=b.map(i=>y[i]), nb=b.length;
        const Hp = Xb.map(x => Array.from({length:16}, (_,j)=>{ let a=this.b1[j]; for(let i=0;i<8;i++) a+=x[i]*this.W1[i][j]; return a; }));
        const H  = Hp.map(h=>h.map(v=>v<0?0:v));
        const L  = H.map(h  => Array.from({length:4},  (_,j)=>{ let a=this.b2[j]; for(let i=0;i<16;i++) a+=h[i]*this.W2[i][j]; return a; }));
        const P  = L.map(l  => { const m=Math.max(...l), e=l.map(v=>Math.exp(v-m)), s=e.reduce((a,b)=>a+b,0); return e.map(v=>v/s); });
        const d2 = P.map((p,i)=>p.map((v,j)=>(v-(j===yb[i]?1:0))/nb));
        const dW2= Array.from({length:16},(_,i)=>Array.from({length:4}, (_,j)=>d2.reduce((a,d,bi)=>a+H[bi][i]*d[j],0)));
        const db2= Array.from({length:4}, (_,j)=>d2.reduce((a,d)=>a+d[j],0));
        const dH = d2.map(d=>Array.from({length:16},(_,i)=>this.W2[i].reduce((a,w,j)=>a+w*d[j],0)));
        const d1 = dH.map((d,bi)=>d.map((v,i)=>Hp[bi][i]>0?v:0));
        const dW1= Array.from({length:8}, (_,i)=>Array.from({length:16},(_,j)=>d1.reduce((a,d,bi)=>a+Xb[bi][i]*d[j],0)));
        const db1= Array.from({length:16},(_,j)=>d1.reduce((a,d)=>a+d[j],0));
        for(let i=0;i<8;i++)  for(let j=0;j<16;j++) this.W1[i][j]-=lr*dW1[i][j];
        for(let j=0;j<16;j++) this.b1[j]-=lr*db1[j];
        for(let i=0;i<16;i++) for(let j=0;j<4;j++)  this.W2[i][j]-=lr*dW2[i][j];
        for(let j=0;j<4;j++)  this.b2[j]-=lr*db2[j];
      }
    }
  }

  // FPGA quantized inference accuracy  (mirrors fpga_accuracy in neural_net.py)
  fpgaAcc(X, y, cfg) {
    const {bit_w} = cfg;
    const cMax=(1<<(bit_w-1))-1, cMin=-(1<<(bit_w-1));
    let absX=0; for(const r of X) for(const v of r) if(Math.abs(v)>absX) absX=Math.abs(v);
    const xSc = absX>0 ? absX/cMax : 1;
    const Xq  = X.map(r => r.map(v => Math.max(cMin, Math.min(cMax, Math.round(v/xSc)))));
    let Hq = fpgaLayer(Xq, quantize2d(this.W1,bit_w), quantize1d(this.b1,bit_w), cfg, true);
    let hAbs=0; for(const r of Hq) for(const v of r) if(Math.abs(v)>hAbs) hAbs=Math.abs(v);
    if (hAbs>0) { const hSc=hAbs/cMax; Hq=Hq.map(r=>r.map(v=>Math.max(cMin,Math.min(cMax,Math.round(v/hSc))))); }
    const Lq = fpgaLayer(Hq, quantize2d(this.W2,bit_w), quantize1d(this.b2,bit_w), {...cfg,act_type:0}, false);
    return Lq.reduce((s,l,i) => s+(l.indexOf(Math.max(...l))===y[i]?1:0), 0) / Lq.length;
  }

  // QAT fine-tuning with straight-through estimator
  qatFinetune(X, y, bit_w, epochs, lr) {
    const cMax=(1<<(bit_w-1))-1, cMin=-(1<<(bit_w-1));
    const fq = W => { let abs=0; for(const r of W) for(const v of r) if(Math.abs(v)>abs) abs=Math.abs(v); if(!abs) return W; const sc=abs/cMax; return W.map(r=>r.map(v=>Math.max(cMin,Math.min(cMax,Math.round(v/sc)))*sc)); };
    const rng=seededRng(77), n=X.length;
    for (let ep=0; ep<epochs; ep++) {
      const idx=Array.from({length:n},(_,i)=>i).sort(()=>rng()-0.5);
      for (let s=0; s<n; s+=32) {
        const b=idx.slice(s,s+32), Xb=b.map(i=>X[i]), yb=b.map(i=>y[i]), nb=b.length;
        const W1f=fq(this.W1), W2f=fq(this.W2);
        const Hp=Xb.map(x=>Array.from({length:16},(_,j)=>{ let a=this.b1[j]; for(let i=0;i<8;i++) a+=x[i]*W1f[i][j]; return a; }));
        const H =Hp.map(h=>h.map(v=>v<0?0:v));
        const L =H.map(h =>Array.from({length:4}, (_,j)=>{ let a=this.b2[j]; for(let i=0;i<16;i++) a+=h[i]*W2f[i][j]; return a; }));
        const P =L.map(l =>{ const m=Math.max(...l),e=l.map(v=>Math.exp(v-m)),s=e.reduce((a,b)=>a+b,0); return e.map(v=>v/s); });
        const d2=P.map((p,i)=>p.map((v,j)=>(v-(j===yb[i]?1:0))/nb));
        const dW2=Array.from({length:16},(_,i)=>Array.from({length:4}, (_,j)=>d2.reduce((a,d,bi)=>a+H[bi][i]*d[j],0)));
        const db2=Array.from({length:4}, (_,j)=>d2.reduce((a,d)=>a+d[j],0));
        const dH =d2.map(d=>Array.from({length:16},(_,i)=>W2f[i].reduce((a,w,j)=>a+w*d[j],0)));
        const d1 =dH.map((d,bi)=>d.map((v,i)=>Hp[bi][i]>0?v:0));
        const dW1=Array.from({length:8}, (_,i)=>Array.from({length:16},(_,j)=>d1.reduce((a,d,bi)=>a+Xb[bi][i]*d[j],0)));
        const db1=Array.from({length:16},(_,j)=>d1.reduce((a,d)=>a+d[j],0));
        for(let i=0;i<8;i++)  for(let j=0;j<16;j++) this.W1[i][j]-=lr*dW1[i][j];
        for(let j=0;j<16;j++) this.b1[j]-=lr*db1[j];
        for(let i=0;i<16;i++) for(let j=0;j<4;j++)  this.W2[i][j]-=lr*dW2[i][j];
        for(let j=0;j<4;j++)  this.b2[j]-=lr*db2[j];
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// HW DOT-PRODUCT PASS RATE  (hard gate: < 0.95 → reward -0.8)
// ═══════════════════════════════════════════════════════════════════════════

function hwPassRate(cfg) {
  const {bit_w, vec_len, act_type} = cfg;
  const hi=(1<<(bit_w-1))-1, lo=-(1<<(bit_w-1));
  const sHi=Math.floor(hi/4), sLo=Math.ceil(lo/4), scale=(hi-lo)||1;
  const rng=seededRng(42); let passes=0;
  for (let t=0; t<64; t++) {
    const w=Array.from({length:vec_len},()=>sLo+Math.floor(rng()*(sHi-sLo+1)));
    const x=Array.from({length:vec_len},()=>sLo+Math.floor(rng()*(sHi-sLo+1)));
    const bias=sLo+Math.floor(rng()*(sHi-sLo+1));
    let ref=bias; for(let i=0;i<vec_len;i++) ref+=w[i]*x[i];
    ref = ref<lo?lo : ref>hi?hi : ref;  // clamp reference
    let out=bias; for(let i=0;i<vec_len;i++) out+=w[i]*x[i];
    if (act_type===1) out=out<0?0:out>hi?hi:out;
    else if (act_type===2) out=out<lo?lo:out>hi?hi:out;
    else { let r=((out%(1<<bit_w))+(1<<bit_w))%(1<<bit_w); if(r>=(1<<(bit_w-1)))r-=(1<<bit_w); out=r; }
    if (Math.abs(out-ref)/scale < 0.10) passes++;
  }
  return passes/64;
}

// ═══════════════════════════════════════════════════════════════════════════
// SYNTHESIS ESTIMATION  (calibrated to match Python models)
// ═══════════════════════════════════════════════════════════════════════════

function synthEst(cfg) {
  const {bit_w, vec_len, pipe_stages, act_type, accum_extra, use_dsp} = cfg;
  const accum_w = bit_w*2 + accum_extra + Math.ceil(Math.log2(Math.max(vec_len,2)));
  const mult_luts  = use_dsp ? 3*vec_len : Math.floor(Math.pow(bit_w,1.4)*vec_len);
  const adder_luts = Math.ceil(Math.ceil(Math.log2(Math.max(vec_len,2))) * accum_w / 4);
  const act_luts   = [0, Math.floor(bit_w/2), bit_w][act_type];
  const luts = mult_luts + adder_luts + act_luts + 8;
  const ffs  = pipe_stages * bit_w + accum_w;
  const dsps = use_dsp ? vec_len : 0;
  const mult_d  = use_dsp ? 2.5 : 0.08 * Math.pow(bit_w, 1.5);
  const adder_d = 0.05 * accum_w;
  const act_d   = [0.0, 0.5, 0.8][act_type];
  const cp      = (mult_d + adder_d + act_d) / pipe_stages + 0.5;
  const frequency = Math.min(500, 1000 / Math.max(cp, 0.1));
  const latency   = pipe_stages + 1;
  return {luts, ffs, dsps, frequency, latency, synthesis_ok:true};
}

// ═══════════════════════════════════════════════════════════════════════════
// REWARD  (mirrors reward.py — 40% inference_acc PRIMARY signal)
// ═══════════════════════════════════════════════════════════════════════════

const NORM = {tput:2000e6, luts:500, freq:200, lat:3};

function reward(m) {
  if (!m.synthesis_ok)        return -1.0;
  if (m.hw_pass_rate < 0.95)  return -0.8;
  const sInf  = Math.max(0, Math.min(m.fpga_acc / Math.max(m.fp32_acc, 1e-6), 1));
  const sTput = Math.min(m.throughput / NORM.tput, 1);
  const sRes  = Math.max(0, Math.min(1, 1 - m.luts / (2*NORM.luts)));
  const sFreq = Math.min(m.frequency / NORM.freq, 1);
  const sLat  = Math.max(0, Math.min(1, 1 - m.latency / (2*NORM.lat)));
  return 0.40*sInf + 0.25*sTput + 0.20*sRes + 0.10*sFreq + 0.05*sLat;
}

// ═══════════════════════════════════════════════════════════════════════════
// Q-LEARNING AGENT
// ═══════════════════════════════════════════════════════════════════════════

let A = newAgent();

function newAgent() {
  return {
    lr: .1, gamma: .9, epsilon: .9, epsilonMin: .05, epsilonDecay: .97,
    qTable: new Map(),   // cfgKey -> Q-value
    history: [],         // [{config, metrics, reward}]
    explored: new Set(), // cfgKeys explored
    bestReward: -Infinity,
    bestEntry: null,
  };
}

function getQ(key)        { return A.qTable.get(key) ?? 0; }
function bestQ()          { let b=-Infinity; for (const c of ALL) { const q=getQ(cfgKey(c)); if(q>b) b=q; } return b; }

function selectConfig() {
  if (Math.random() < A.epsilon) {
    const pool = ALL.filter(c => !A.explored.has(cfgKey(c)));
    const src  = pool.length ? pool : ALL;
    return {cfg: src[Math.floor(Math.random()*src.length)], method:'explore'};
  }
  let best=ALL[0], bq=-Infinity;
  for (const c of ALL) { const q=getQ(cfgKey(c)); if(q>bq){bq=q;best=c;} }
  return {cfg: best, method:'exploit'};
}

function agentUpdate(cfg, r) {
  const key = cfgKey(cfg);
  const bq  = bestQ();
  const td  = r + A.gamma * bq;
  A.qTable.set(key, (1-A.lr)*getQ(key) + A.lr*td);
  A.explored.add(key);
  const entry = {config:{...cfg}, reward:r};
  A.history.push(entry);
  if (r > A.bestReward) { A.bestReward = r; A.bestEntry = {...entry}; }
  A.epsilon = Math.max(A.epsilonMin, A.epsilon * A.epsilonDecay);
}

function topN(n) {
  return [...A.explored]
    .map(k => ({key:k, q:getQ(k)}))
    .sort((a,b)=>b.q-a.q).slice(0,n)
    .map(({key,q}) => {
      const parts = key.split(',').map(Number);
      const cfg = {}; PNAMES.forEach((p,i)=>cfg[p]=parts[i]);
      return {cfg, q};
    });
}

function insights() {
  const h = A.history;
  if (h.length < 8) return null;
  const sorted = [...h].sort((a,b)=>b.reward-a.reward);
  const topK = sorted.slice(0, Math.max(1, Math.floor(h.length/4)));
  const botK = sorted.slice(-Math.max(1, Math.floor(h.length/4)));
  const result = {};
  for (const p of PNAMES) {
    const tCnt={}, bCnt={};
    for (const e of topK) tCnt[e.config[p]] = (tCnt[e.config[p]]||0)+1;
    for (const e of botK) bCnt[e.config[p]] = (bCnt[e.config[p]]||0)+1;
    const pref = PARAM_SPACE[p]
      .map(v => ({v, diff: (tCnt[v]||0)/topK.length - (bCnt[v]||0)/botK.length}))
      .filter(x=>x.diff>0.08).sort((a,b)=>b.diff-a.diff);
    if (pref.length) result[p] = pref;
  }
  return result;
}

// ═══════════════════════════════════════════════════════════════════════════
// ONE ITERATION
// ═══════════════════════════════════════════════════════════════════════════

function runIter() {
  const {cfg, method} = selectConfig();
  const syn  = synthEst(cfg);
  const tput = syn.frequency * 1e6 * cfg.vec_len;
  const m = {
    synthesis_ok: true,
    luts: syn.luts, ffs: syn.ffs, dsps: syn.dsps,
    frequency: syn.frequency, latency: syn.latency,
    throughput: tput, ops_per_lut: tput/Math.max(syn.luts,1),
    hw_pass_rate: hwPassRate(cfg),
    fpga_acc: nn.fpgaAcc(DS.X, DS.y, cfg),
    fp32_acc: nnFp32Acc,
  };
  const prevBest = A.bestReward;
  const r = reward(m);
  agentUpdate(cfg, r);
  const doQat = (iterDone % 10 === 9);
  return {cfg, method, metrics:m, reward:r, isBest: r > prevBest, doQat};
}

// ═══════════════════════════════════════════════════════════════════════════
// VERILOG GENERATOR  (matches verilog_gen.py)
// ═══════════════════════════════════════════════════════════════════════════

function genVerilog(cfg, iter=0) {
  const {bit_w, vec_len, pipe_stages, act_type, accum_extra, use_dsp} = cfg;
  const accum_w  = bit_w*2 + accum_extra + Math.ceil(Math.log2(Math.max(vec_len,2)));
  const act_str  = ACT[act_type];
  const dsp_str  = use_dsp ? 'DSP' : 'LUT';
  const clamp_max = (1<<(bit_w-1))-1;
  const clamp_min = -(1<<(bit_w-1));

  const psum_expr = Array.from({length:vec_len},(_,i)=>`psum[${i}]`).join(' + ');

  let act_assign;
  if (act_type === 0) {
    act_assign = `act_in[${bit_w-1}:0]; // truncate`;
  } else if (act_type === 1) {
    act_assign =
      `(act_in[${accum_w-1}]) ? ${bit_w}'d0 :  // negative -> 0\n` +
      `        (act_in > ${accum_w}'sd${clamp_max}) ? ${bit_w}'sd${clamp_max} :\n` +
      `        act_in[${bit_w-1}:0];`;
  } else {
    act_assign =
      `(act_in > ${accum_w}'sd${clamp_max}) ? ${bit_w}'sd${clamp_max} :\n` +
      `        (act_in < ${accum_w}'sd${clamp_min}) ? ${bit_w}'sd${clamp_min} :\n` +
      `        act_in[${bit_w-1}:0];`;
  }

  let pipe_reg;
  if (pipe_stages === 1) {
    pipe_reg = `    reg signed [${bit_w-1}:0] y_reg;\n` +
      `    always @(posedge clk or negedge rst_n) begin\n` +
      `        if (!rst_n) y_reg <= ${bit_w}'d0;\n` +
      `        else        y_reg <= act_out;\n    end`;
  } else if (pipe_stages === 2) {
    pipe_reg = `    reg signed [${bit_w-1}:0] y_p1, y_reg;\n` +
      `    always @(posedge clk or negedge rst_n) begin\n` +
      `        if (!rst_n) begin y_p1 <= ${bit_w}'d0; y_reg <= ${bit_w}'d0; end\n` +
      `        else        begin y_p1 <= act_out;   y_reg <= y_p1;   end\n    end`;
  } else {
    pipe_reg = `    reg signed [${bit_w-1}:0] y_p1, y_p2, y_reg;\n` +
      `    always @(posedge clk or negedge rst_n) begin\n` +
      `        if (!rst_n) begin y_p1<=${bit_w}'d0; y_p2<=${bit_w}'d0; y_reg<=${bit_w}'d0; end\n` +
      `        else        begin y_p1<=act_out; y_p2<=y_p1; y_reg<=y_p2; end\n    end`;
  }

  return (
`// ============================================================
// dot_product_unit.v  —  AI-FPGA-Loop  iter ${String(iter).padStart(4,'0')}
// Config : bit_w=${bit_w} vec_len=${vec_len} pipe_stages=${pipe_stages}
//          act=${act_str} accum_extra=${accum_extra} mult=${dsp_str}
// ============================================================
\`timescale 1ns/1ps

module dot_product_unit #(
    parameter BIT_W       = ${bit_w},
    parameter VEC_LEN     = ${vec_len},
    parameter PIPE_STAGES = ${pipe_stages},
    parameter ACT_TYPE    = ${act_type},  // 0=none 1=relu 2=clamp
    parameter ACCUM_EXTRA = ${accum_extra},
    parameter USE_DSP     = ${use_dsp},
    parameter ACCUM_W     = ${accum_w},
    parameter PROD_W      = BIT_W * 2
) (
    input  wire                             clk,
    input  wire                             rst_n,   // async active-low reset
    input  wire signed [BIT_W*VEC_LEN-1:0] w_flat,  // weight vector (packed)
    input  wire signed [BIT_W*VEC_LEN-1:0] x_flat,  // input  vector (packed)
    input  wire signed [BIT_W-1:0]         bias,
    output reg  signed [BIT_W-1:0]         y
);

    // ── Unpack flat ports into arrays ─────────────────────────
    wire signed [BIT_W-1:0] w [0:VEC_LEN-1];
    wire signed [BIT_W-1:0] x [0:VEC_LEN-1];
    genvar k;
    generate
        for (k = 0; k < VEC_LEN; k = k + 1) begin : unpack
            assign w[k] = w_flat[BIT_W*(k+1)-1 : BIT_W*k];
            assign x[k] = x_flat[BIT_W*(k+1)-1 : BIT_W*k];
        end
    endgenerate

    // ── Multiplier array (${dsp_str}) ──────────────────────────
    wire signed [PROD_W-1:0] products [0:VEC_LEN-1];
    genvar i;
    generate
        for (i = 0; i < VEC_LEN; i = i + 1) begin : mult_array
            (* use_dsp = "${use_dsp ? 'yes' : 'no'}" *)
            assign products[i] = $signed(w[i]) * $signed(x[i]);
        end
    endgenerate

    // ── Sign-extended partial sums ────────────────────────────
    wire signed [ACCUM_W-1:0] psum [0:VEC_LEN-1];
    genvar j;
    generate
        for (j = 0; j < VEC_LEN; j = j + 1) begin : psum_init
            assign psum[j] = {{(ACCUM_W-PROD_W){products[j][PROD_W-1]}}, products[j]};
        end
    endgenerate

    // ── Adder tree ────────────────────────────────────────────
    wire signed [ACCUM_W-1:0] tree_sum;
    assign tree_sum = ${psum_expr};

    wire signed [ACCUM_W-1:0] biased_sum;
    assign biased_sum = tree_sum +
        $signed({{(ACCUM_W-BIT_W){bias[BIT_W-1]}}, bias});

    // ── Activation: ${act_str} ────────────────────────────────
    wire signed [ACCUM_W-1:0] act_in;
    wire signed [BIT_W-1:0]   act_out;
    assign act_in  = biased_sum;
    assign act_out =
        ${act_assign}

    // ── Pipeline registers (depth=${pipe_stages}, async rst_n) ─
${pipe_reg}

    always @(*) y = y_reg;

endmodule
// end of dot_product_unit`
  );
}

// ═══════════════════════════════════════════════════════════════════════════
// VERILOG SYNTAX HIGHLIGHTER
// ═══════════════════════════════════════════════════════════════════════════

const KW = ['module','endmodule','parameter','localparam','input','output',
            'wire','reg','assign','always','if','else','begin','end',
            'generate','endgenerate','genvar','for','signed','posedge','negedge',
            'timescale'];

function hiVerilog(code) {
  let s = code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  // comments (must go first)
  s = s.replace(/(\/\/[^\n]*)/g, '<span class="vcmt">$1</span>');
  // radix numbers
  s = s.replace(/\b(\d+)'([bBdDhH][0-9a-fA-FxXzZ_]+)/g,
                '<span class="vnum">$1\'$2</span>');
  // plain numbers (not inside spans)
  s = s.replace(/(?<![a-zA-Z_"'])(\b\d+\b)(?![a-zA-Z_"'])/g,
                '<span class="vnum">$1</span>');
  // module name
  s = s.replace(/\b(dot_product_unit)\b/g, '<span class="vmod">$1</span>');
  // keywords
  for (const kw of KW)
    s = s.replace(new RegExp(`\\b(${kw})\\b`,'g'), '<span class="vkw">$1</span>');
  // UPPER_CASE params/ports
  s = s.replace(/\b([A-Z][A-Z_0-9]{2,})\b/g, '<span class="vpar">$1</span>');
  // port direction words already handled by keywords
  return s;
}

// ═══════════════════════════════════════════════════════════════════════════
// CHART
// ═══════════════════════════════════════════════════════════════════════════

let chart;
function initChart() {
  const ctx = document.getElementById('chart').getContext('2d');
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label:'Reward', data:[], borderColor:'#3fb950',
          backgroundColor:'rgba(63,185,80,.07)', borderWidth:1.5,
          pointRadius:2, pointHoverRadius:5, fill:true, tension:.25 },
        { label:'Best so far', data:[], borderColor:'#79c0ff',
          borderWidth:1, pointRadius:0, fill:false,
          borderDash:[5,5], tension:0 },
        { label:'FPGA Acc', data:[], borderColor:'#bc8cff',
          borderWidth:1.5, pointRadius:0, fill:false, tension:.25,
          yAxisID:'yAcc' },
      ]
    },
    options: {
      responsive:true, maintainAspectRatio:false, animation:false,
      plugins:{
        legend:{ labels:{ color:'#8b949e', font:{family:'Consolas',size:10} } }
      },
      scales:{
        x:{ grid:{color:'rgba(48,54,61,.45)'},
            ticks:{color:'#8b949e', font:{size:9}, maxTicksLimit:12} },
        y:{ min:-1.05, max:1.05,
            grid:{color:'rgba(48,54,61,.45)'},
            ticks:{color:'#8b949e', font:{size:9}} },
        yAcc:{ position:'right', min:0, max:1.05, grid:{display:false},
               ticks:{color:'#bc8cff', font:{size:9},
                      callback: v => (v*100).toFixed(0)+'%'} },
      }
    }
  });
}

// ═══════════════════════════════════════════════════════════════════════════
// UI UPDATE
// ═══════════════════════════════════════════════════════════════════════════

let iterDone = 0;
let curVerilog = '';

function ui({cfg, method, metrics:m, reward:r, isBest, doQat}) {
  iterDone++;

  // Config
  [cfg.bit_w, cfg.vec_len, cfg.pipe_stages, ACT[cfg.act_type], cfg.accum_extra, cfg.use_dsp?'DSP':'LUT']
    .forEach((v,i) => el('c'+i).textContent = v);

  // Metrics
  el('m0').textContent = m.luts;
  el('m1').textContent = m.frequency.toFixed(0) + ' MHz';
  el('m2').textContent = (m.throughput/1e6).toFixed(0);
  const me = el('m3');
  me.textContent = (m.fpga_acc*100).toFixed(1)+'%';
  me.className   = 'mv ' + (m.fpga_acc>0.85?'g':m.fpga_acc>0.6?'y':'r');
  const re = el('m4');
  re.textContent = fmt(r);
  re.className   = 'mv ' + rClass(r);
  el('fp32-acc').textContent  = (m.fp32_acc*100).toFixed(1)+'%';
  el('acc-ratio').textContent = (m.fpga_acc/Math.max(m.fp32_acc,1e-6)*100).toFixed(0)+'%';

  // Chart (cap at 300 pts for performance)
  if (chart.data.labels.length >= 300) {
    chart.data.labels.shift();
    chart.data.datasets[0].data.shift();
    chart.data.datasets[1].data.shift();
    chart.data.datasets[2].data.shift();
  }
  chart.data.labels.push(iterDone);
  chart.data.datasets[0].data.push(r);
  chart.data.datasets[1].data.push(A.bestReward === -Infinity ? null : A.bestReward);
  chart.data.datasets[2].data.push(m.fpga_acc);
  chart.update('none');

  // Exploration
  const exp = A.explored.size;
  el('exp-n').textContent   = exp;
  el('exp-bar').style.width = (exp/NTOT*100).toFixed(1)+'%';
  el('eps-live').textContent = A.epsilon.toFixed(3);
  el('iter-n').textContent   = iterDone;

  // Best design
  if (A.bestEntry) {
    const bc = A.bestEntry.config;
    el('best-r').textContent   = fmt(A.bestReward);
    el('best-cfg').textContent = `bit_w=${bc.bit_w} vec=${bc.vec_len} pipe=${bc.pipe_stages} act=${ACT[bc.act_type]}`;
    if (A.bestEntry.metrics) {
      const bm2 = A.bestEntry.metrics;
      el('best-met').textContent =
        `LUTs=${bm2.luts} · ${bm2.frequency.toFixed(0)}MHz · FPGA=${(bm2.fpga_acc*100).toFixed(0)}%`;
    }
  }

  // Trend
  const h = A.history;
  if (h.length >= 4) {
    const n1 = Math.min(10, h.length);
    const f  = h.slice(0,n1).reduce((a,e)=>a+e.reward,0)/n1;
    const l  = h.slice(-n1).reduce((a,e)=>a+e.reward,0)/n1;
    const ar = l > f ? '↑' : '↓';
    const col = l > f ? 'var(--green)' : 'var(--red)';
    el('trend').innerHTML = `<span style="color:${col}">${ar}</span> ${f.toFixed(3)} → ${l.toFixed(3)}`;
  }

  // Top-3
  const t3 = topN(3);
  el('top3').innerHTML = t3.length ? t3.map((d,i)=>{
    const c=d.cfg;
    return `<div style="margin:2px 0">
      <span style="color:var(--dim)">${i+1}.</span>
      <span style="color:var(--cyan)">Q=${d.q.toFixed(3)}</span>
      &nbsp;b=${c.bit_w} v=${c.vec_len} p=${c.pipe_stages} ${ACT[c.act_type]} ${c.use_dsp?'DSP':'LUT'}
    </div>`;
  }).join('') : 'Not yet explored.';

  // AI insights
  const ins = insights();
  if (ins) {
    el('insights').innerHTML = Object.entries(ins).map(([p, pref]) => {
      const vals = pref.slice(0,3).map(({v,diff})=>`<span style="color:var(--green)">${v}(+${(diff*100).toFixed(0)}%)</span>`).join(' ');
      return `<div style="margin:1px 0"><span style="color:var(--dim)">${p}:</span> ${vals}</div>`;
    }).join('');
  }

  // Log row (prepend = newest on top)
  const tbody = el('log-body');
  const row   = document.createElement('tr');
  if (isBest) row.className = 'best-row';
  const ratPct = (m.fpga_acc/Math.max(m.fp32_acc,1e-6)*100).toFixed(0)+'%';
  row.innerHTML = `
    <td>${String(iterDone).padStart(3,'0')}${isBest?' ★':''}</td>
    <td class="${method==='explore'?'me':'mx'}">${method}</td>
    <td>${cfg.bit_w}</td><td>${cfg.vec_len}</td><td>${cfg.pipe_stages}</td>
    <td>${ACT[cfg.act_type]}</td><td>${cfg.use_dsp?'DSP':'LUT'}</td>
    <td>${m.luts}</td><td>${m.frequency.toFixed(0)}</td>
    <td>${(m.throughput/1e6).toFixed(0)}</td>
    <td>${(m.fp32_acc*100).toFixed(1)}%</td>
    <td class="${m.fpga_acc>0.8?'rg':m.fpga_acc>0.5?'ry':'rr'}">${(m.fpga_acc*100).toFixed(1)}%</td>
    <td>${ratPct}</td>
    <td class="${rClass(r)}">${fmt(r)}</td>`;
  tbody.insertBefore(row, tbody.firstChild);
  el('log-n').textContent = iterDone;

  // Verilog (new best or every 5 iters)
  if (isBest || iterDone % 5 === 0) {
    const vcode = genVerilog(cfg, iterDone);
    curVerilog  = vcode;
    el('vcode').innerHTML = hiVerilog(vcode);
    el('v-label').textContent =
      `bit_w=${cfg.bit_w} vec=${cfg.vec_len} pipe=${cfg.pipe_stages} act=${ACT[cfg.act_type]} dsp=${cfg.use_dsp?'DSP':'LUT'}`;
    if (isBest) A.bestEntry.metrics = m;
  }

  el('status-badge').textContent = `iter ${iterDone} · ε=${A.epsilon.toFixed(2)}`;

  // QAT every 10 iterations (deferred to keep UI responsive)
  if (doQat) {
    const bestCfg = A.bestEntry ? A.bestEntry.config : cfg;
    setTimeout(() => {
      nn.qatFinetune(DS.X, DS.y, bestCfg.bit_w, 15, 0.003);
      nnFp32Acc = nn.fp32Accuracy(DS.X, DS.y);
      el('fp32-acc').textContent = (nnFp32Acc*100).toFixed(1)+'% ✦QAT';
    }, 0);
  }
}

function el(id) { return document.getElementById(id); }
function fmt(r) { return (r>=0?'+':'')+r.toFixed(4); }
function rClass(r) { return r>0.5?'rg':r>0?'ry':'rr'; }

// ═══════════════════════════════════════════════════════════════════════════
// RUN CONTROL
// ═══════════════════════════════════════════════════════════════════════════

let running = false, runTimer = null, runTarget = 0;

function toggleRun() {
  if (running) { stopRun(); } else { startRun(); }
}

function startRun() {
  if (!nn || !DS) { el('status-badge').textContent = 'Still initialising NN…'; return; }
  A.lr           = +el('lr-r').value;
  A.epsilonDecay = +el('decay-r').value;
  runTarget = iterDone + (+el('iters-n').value || 50);
  const speed = +el('speed-s').value;
  running = true;
  el('run-btn').textContent = '⏸ Pause';
  el('run-btn').className   = 'stop';
  el('step-btn').disabled   = true;
  el('run-dot').style.display = 'inline-block';

  if (speed === 0) {
    while (running && iterDone < runTarget) { ui(runIter()); }
    stopRun();
    return;
  }
  (function tick() {
    if (!running || iterDone >= runTarget) { stopRun(); return; }
    ui(runIter());
    runTimer = setTimeout(tick, speed);
  })();
}

function stopRun() {
  running = false;
  if (runTimer) { clearTimeout(runTimer); runTimer = null; }
  el('run-btn').textContent = '▶ Run';
  el('run-btn').className   = 'go';
  el('step-btn').disabled   = false;
  el('run-dot').style.display = 'none';
  el('status-badge').textContent = iterDone ? `Done (${iterDone} iters)` : 'Ready';
}

function stepOne() {
  if (running || !nn || !DS) return;
  A.lr           = +el('lr-r').value;
  A.epsilonDecay = +el('decay-r').value;
  ui(runIter());
}

function resetAgent(resetEps=false) {
  stopRun();
  const eps  = resetEps ? +el('eps-r').value : A.epsilon;
  A = newAgent();
  A.lr           = +el('lr-r').value;
  A.epsilon      = eps;
  A.epsilonDecay = +el('decay-r').value;
  iterDone   = 0;
  curVerilog = '';

  // Reset chart
  chart.data.labels = [];
  chart.data.datasets[0].data = [];
  chart.data.datasets[1].data = [];
  chart.data.datasets[2].data = [];
  chart.update();

  // Reset metrics cards
  ['m0','m1','m2','m3','m4'].forEach(id=>{
    el(id).textContent='—'; el(id).className='mv';
  });
  el('fp32-acc').textContent = (nnFp32Acc*100).toFixed(1)+'%';
  el('acc-ratio').textContent = '—';
  // Reset config cells
  ['c0','c1','c2','c3','c4','c5'].forEach(id => el(id).textContent='—');
  // Reset stats
  el('exp-n').textContent='0'; el('exp-bar').style.width='0%';
  el('eps-live').textContent=A.epsilon.toFixed(3);
  el('iter-n').textContent='0';
  el('best-r').textContent='—';
  el('best-cfg').textContent='Run to find the best design';
  el('best-met').textContent='';
  el('trend').textContent='—';
  el('top3').textContent='Run to explore configs.';
  el('insights').textContent='Needs ≥ 8 iterations.';
  el('log-body').innerHTML=''; el('log-n').textContent='0';
  el('vcode').innerHTML='<span class="vcmt">// Verilog will appear here</span>';
  el('v-label').textContent='no design yet';
  el('status-badge').textContent='Ready';
}

function clearLog() {
  el('log-body').innerHTML='';
  el('log-n').textContent='0';
}

function copyV() {
  if (!curVerilog) return;
  navigator.clipboard.writeText(curVerilog).then(()=>{
    el('copy-btn').textContent='Copied!';
    setTimeout(()=>el('copy-btn').textContent='Copy', 1500);
  });
}

function downloadV() {
  if (!curVerilog) return;
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([curVerilog], {type:'text/plain'}));
  a.download = 'dot_product_unit.v';
  a.click();
}

// ── Range → display ───────────────────────────────────────────────────────
function bindRange(id, dispId, fn) {
  const r=el(id), d=el(dispId);
  r.addEventListener('input', ()=>d.textContent=fn(+r.value));
}
bindRange('lr-r',    'lr-v',    v=>v.toFixed(2));
bindRange('eps-r',   'eps-v',   v=>v.toFixed(2));
bindRange('decay-r', 'decay-v', v=>v.toFixed(3));

// ── Init ──────────────────────────────────────────────────────────────────
// Globals populated after training
let DS = null, nn = null, nnFp32Acc = 0;

initChart();
el('status-badge').textContent = 'Training NN…';

// Defer NN init + training so the browser can render the page first
setTimeout(() => {
  DS = makeDataset(20, 0);          // 80 samples (20 per class)
  nn = new TinyMLP(0);
  nn.train(DS.X, DS.y, 120, 0.025, 32);
  nnFp32Acc = nn.fp32Accuracy(DS.X, DS.y);
  el('fp32-acc').textContent = (nnFp32Acc*100).toFixed(1)+'%';
  el('status-badge').textContent = `Ready · FP32 ${(nnFp32Acc*100).toFixed(0)}%`;
}, 60);
</script>
</body>
</html>
